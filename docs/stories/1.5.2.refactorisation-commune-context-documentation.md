# Story 1.5.2: refactorisation-commune-context-documentation

## Status
Draft

## Story
**As a** Développeur,
**I want** factoriser les composants communs entre les pages context et documentation pour maximiser la réutilisation,
**so that** je puisse maintenir une UI cohérente avec des comportements IA différenciés selon le contexte.

## Acceptance Criteria
1. Composant `UniversalTreePanel` créé, utilisable pour context (lecture seule) et documentation (éditable)
2. Composant `UniversalContentPanel` créé, supportant Monaco (context) et TipTap (documentation)
3. Composant `UniversalChatPanel` créé avec système de prompts contextuels différenciés
4. Les deux pages utilisent les composants universels avec des configurations spécifiques
5. Aucune régression fonctionnelle dans context ou documentation
6. Interface IA différenciée : analysis/exploration dans context, documentation/enrichissement dans documentation
7. Architecture extensible pour futures pages utilisant le même pattern 3-panneaux

## Business Value
- **Réutilisabilité :** Composants universels utilisables dans multiples contextes
- **Cohérence UX :** Interface utilisateur unifiée à travers l'application
- **IA Contextuelle :** Prompts et comportements IA adaptés au contexte d'usage
- **Maintenabilité :** Code factorísé plus facile à maintenir et faire évoluer
- **Extensibilité :** Architecture préparée pour futures fonctionnalités (Epic 2, 3, 4)

## Tasks / Subtasks

### Phase 1: Architecture des Composants Universels (AC: 1, 2, 3)
- [ ] Créer `lib/types/universal-components.ts` avec interfaces communes
- [ ] Définir les enums `PanelMode` et `ChatContextType` pour différencier les comportements
- [ ] Créer les interfaces de configuration pour chaque type de panneau
- [ ] Analyser les props communes vs spécifiques entre context et documentation

### Phase 2: Composant UniversalTreePanel (AC: 1)
- [ ] Créer `components/universal/UniversalTreePanel.tsx` (~150 lignes)
- [ ] Implémenter le mode `readonly` (context) et `editable` (documentation)
- [ ] Factoriser la logique d'affichage arborescence commune (react-arborist)
- [ ] Gérer les événements conditionnels selon le mode (CRUD vs sélection simple)
- [ ] Interface de configuration pour icônes, actions contextuelles

### Phase 3: Composant UniversalContentPanel (AC: 2)
- [ ] Créer `components/universal/UniversalContentPanel.tsx` (~120 lignes)
- [ ] Support dual-editor : Monaco (mode `code`) et TipTap (mode `document`)
- [ ] Gestion des états communs (loading, saving, content)
- [ ] Interface unified pour onChange et onSave
- [ ] Configuration des options spécifiques par éditeur

### Phase 4: Composant UniversalChatPanel (AC: 3, 6)
- [ ] Créer `components/universal/UniversalChatPanel.tsx` (~100 lignes)
- [ ] Système de prompts contextuels : `analysis` (context) vs `documentation` (documentation)
- [ ] Interface pour injection de prompts système différenciés
- [ ] Gestion des contextes IA spécialisés selon la page
- [ ] Préparation pour intégration IA réelle (Epic 2)

### Phase 5: Migration Page Context (AC: 4)
- [ ] Migrer `app/(pages)/workspaces/[id]/context/page.tsx` vers composants universels
- [ ] Configuration mode `readonly` pour UniversalTreePanel
- [ ] Configuration mode `code` pour UniversalContentPanel  
- [ ] Configuration contexte `analysis` pour UniversalChatPanel
- [ ] Valider comportement identique à avant refactoring

### Phase 6: Migration Page Documentation (AC: 4)
- [ ] Migrer `app/(pages)/workspaces/[id]/documentation/page.tsx` vers composants universels
- [ ] Configuration mode `editable` pour UniversalTreePanel
- [ ] Configuration mode `document` pour UniversalContentPanel
- [ ] Configuration contexte `documentation` pour UniversalChatPanel
- [ ] Valider toutes fonctionnalités CRUD conservées

### Phase 7: Tests et Validation (AC: 5, 7)
- [ ] Tests unitaires des composants universels
- [ ] Tests d'intégration des deux pages migrées
- [ ] Validation parcours utilisateur complets (context + documentation)
- [ ] Tests de régression automatisés
- [ ] Documentation d'utilisation des composants universels

## Dev Notes

### Analyse des Similitudes et Différences

**Similitudes identifiées (factorisation possible) :**
- Structure layout 3-panneaux avec react-resizable-panels
- Gestion d'état selectedFile/selectedNode pattern
- Interface de chat pour assistance IA
- Loading states et error handling
- Responsive design et thèmes sombres

**Différences à préserver (configuration) :**
- **TreePanel :** readonly vs editable, FileTreeNode vs DocumentationNode
- **ContentPanel :** Monaco Editor vs TipTap Editor, code vs markdown
- **ChatPanel :** prompts analysis vs documentation, contextes différents

### Architecture Universelle Cible

**Structure Après Factorisation :**
```
apps/web/src/
├── lib/types/
│   ├── universal-components.ts             # Types composants universels
│   ├── common.ts                          # TreeNodeBase interface
│   ├── context.ts                         # Types context spécifiques
│   └── documentation.ts                   # Types documentation spécifiques
├── components/
│   ├── universal/                         # Composants universels
│   │   ├── UniversalTreePanel.tsx         # Arborescence configurable
│   │   ├── UniversalContentPanel.tsx      # Éditeur dual Monaco/TipTap
│   │   └── UniversalChatPanel.tsx         # Chat avec contextes IA
│   └── [autres composants spécifiques]
└── app/(pages)/workspaces/[id]/
    ├── context/page.tsx                   # Mode: readonly, code, analysis
    └── documentation/page.tsx             # Mode: editable, document, documentation
```

### Spécifications des Composants Universels

#### 1. `UniversalTreePanel.tsx` - Arborescence Configurable (~150 lignes)

**Configuration Mode :**
```typescript
type TreePanelMode = 'readonly' | 'editable'

interface UniversalTreePanelProps<T extends TreeNodeBase> {
  data: T[]
  selectedId?: string
  mode: TreePanelMode
  onSelect: (node: T | null) => void
  
  // Conditionnel selon mode
  crudActions?: TreeCRUDActions<T>  // Si mode = 'editable'
  
  // Configuration UI
  config: {
    title: string
    showCount: boolean
    icons: TreeIconConfig
    contextActions?: TreeContextAction[]
  }
}
```

#### 2. `UniversalContentPanel.tsx` - Éditeur Dual (~120 lignes)

**Configuration Éditeur :**
```typescript
type ContentPanelMode = 'code' | 'document'

interface UniversalContentPanelProps {
  selectedItem: TreeNodeBase | null
  content: string
  mode: ContentPanelMode
  
  onChange: (content: string) => void
  onSave?: (content: string) => Promise<void>
  
  // Configuration selon mode
  editorConfig: MonacoConfig | TipTapConfig
  
  // États communs
  isLoading?: boolean
  isSaving?: boolean
}
```

#### 3. `UniversalChatPanel.tsx` - Chat Contextuel (~100 lignes)

**Configuration IA :**
```typescript
type ChatContextType = 'analysis' | 'documentation'

interface UniversalChatPanelProps {
  contextType: ChatContextType
  selectedItem?: TreeNodeBase | null
  workspaceId: string
  
  onSendMessage: (message: string) => Promise<void>
  messages: ChatMessage[]
  isLoading?: boolean
  
  // Configuration contexte IA
  prompts: {
    systemPrompt: string
    contextPrompts: ContextPromptConfig
    suggestions: string[]
  }
}
```

### Système de Prompts Différenciés

**Context IA (Analysis/Exploration) :**
```typescript
const CONTEXT_PROMPTS = {
  systemPrompt: "Tu es un assistant IA spécialisé dans l'analyse de code...",
  contextPrompts: {
    fileSelected: "Analyse ce fichier {fileName} de type {language}...",
    suggestions: [
      "Explique-moi ce code",
      "Trouve les dépendances",
      "Identifie les problèmes potentiels",
      "Propose des améliorations"
    ]
  }
}
```

**Documentation IA (Documentation/Enrichissement) :**
```typescript
const DOCUMENTATION_PROMPTS = {
  systemPrompt: "Tu es un assistant IA spécialisé dans la création de documentation...",
  contextPrompts: {
    fileSelected: "Aide-moi à enrichir ce document {fileName}...",
    suggestions: [
      "Améliore cette documentation",
      "Ajoute des exemples",
      "Restructure le contenu",
      "Génère du contenu manquant"
    ]
  }
}
```

### Configuration par Page

**Page Context (Mode Analysis) :**
```typescript
// apps/web/src/app/(pages)/workspaces/[id]/context/page.tsx
const CONTEXT_CONFIG = {
  tree: {
    mode: 'readonly' as const,
    title: 'Arborescence',
    showCount: true,
    icons: CODE_ICONS
  },
  content: {
    mode: 'code' as const,
    editorConfig: MONACO_CONFIG
  },
  chat: {
    contextType: 'analysis' as const,
    prompts: CONTEXT_PROMPTS
  }
}
```

**Page Documentation (Mode Documentation) :**
```typescript
// apps/web/src/app/(pages)/workspaces/[id]/documentation/page.tsx
const DOCUMENTATION_CONFIG = {
  tree: {
    mode: 'editable' as const,
    title: 'Documentation',
    showCount: true,
    icons: DOC_ICONS,
    crudActions: DOCUMENTATION_CRUD
  },
  content: {
    mode: 'document' as const,
    editorConfig: TIPTAP_CONFIG
  },
  chat: {
    contextType: 'documentation' as const,
    prompts: DOCUMENTATION_PROMPTS
  }
}
```

### Avantages de la Factorisation

1. **Réutilisabilité Maximale**
   - Composants universels pour futures pages (ex: Epic 3 - Code Review)
   - Configuration flexible sans duplication
   - Patterns UI cohérents à travers l'app

2. **IA Contextuelle**
   - Prompts spécialisés selon le contexte d'usage
   - Comportements IA différenciés mais interface uniforme
   - Extensibilité pour nouveaux contextes IA

3. **Maintenabilité Optimale**
   - Corrections/améliorations bénéficient à toutes les pages
   - Tests centralisés sur composants universels
   - Évolution coordonnée de l'interface

4. **Architecture Extensible**
   - Pattern 3-panneaux réutilisable (Epic 2, 3, 4)
   - Système de configuration pour nouveaux modes
   - Foundation solide pour futures fonctionnalités

### Plan de Migration Sécurisé

1. **Phase 1 :** Types et architecture des composants universels
2. **Phase 2-4 :** Création composants universels avec tous les modes
3. **Phase 5 :** Migration context (moins de risque, plus simple)  
4. **Phase 6 :** Migration documentation (plus complexe, CRUD)
5. **Phase 7 :** Validation complète et optimisations

**Durée Estimée :** 4-5 jours de développement.
**Complexité :** Élevée - refactoring majeur avec risques de régression.

## Dependencies et Prérequis
- Story 1.5.1 doit être complètement terminée (refactoring documentation)
- Story 1.3.1 doit être validée (refactoring context)
- Tests automatisés robustes en place pour détection régressions
- Validation équipe sur l'approche architecture universelle

## Acceptance Tests
1. **Test Context :** Comportement identical après migration vers composants universels
2. **Test Documentation :** Toutes fonctionnalités CRUD conservées après migration
3. **Test IA Différenciée :** Prompts et contextes IA appropriés selon la page
4. **Test Réutilisabilité :** Possibilité créer nouvelle page 3-panneaux facilement
5. **Test Performance :** Aucune dégradation performance après factorisation
