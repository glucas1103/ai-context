# Story 1.3: analyse-statique-codebase

## Status
Draft

## Story
**As a** Système,
**I want** cloner un dépôt sélectionné et analyser sa structure de fichiers,
**so that** je puisse générer une représentation structurée de l'arborescence du projet pour créer la base de connaissances.

## Acceptance Criteria
1. Le back-end peut analyser l'arborescence d'un dépôt privé en utilisant le jeton d'accès de l'utilisateur
2. Le système parcourt l'arborescence du projet cloné
3. Le système génère une représentation structurée (ex: JSON) de l'arborescence des fichiers
4. L'analyse respecte les limites de performance (< 30 minutes pour 100k lignes de code selon NFR1)
5. Les données d'analyse sont stockées de manière sécurisée dans Supabase
6. L'interface utilisateur affiche le progrès de l'analyse en temps réel
7. L'analyse gère les dépôts de grande taille sans épuiser les ressources système

## Tasks / Subtasks
- [ ] Créer l'API d'analyse de dépôt (AC: 1, 2, 3)
  - [ ] Créer `/apps/web/app/api/workspaces/[id]/analyze/route.ts`
  - [ ] Implémenter l'authentification GitHub avec le token utilisateur
  - [ ] Intégrer l'API GitHub Trees pour récupérer l'arborescence complète
  - [ ] Gérer les limitations de l'API GitHub (récursion, pagination)
- [ ] Développer le moteur d'analyse de fichiers (AC: 2, 3, 4)
  - [ ] Créer `lib/server/github.ts` pour les interactions GitHub
  - [ ] Implémenter le parsing de l'arborescence GitHub (trees API)
  - [ ] Générer la structure JSON standardisée de l'arborescence
  - [ ] Optimiser l'analyse pour respecter la limite de 30 minutes
- [ ] Intégrer le stockage Supabase (AC: 5)
  - [ ] Créer les tables `workspaces` et `knowledge_bases` selon le schema
  - [ ] Implémenter l'insertion sécurisée des données d'analyse
  - [ ] Configurer Row Level Security (RLS) pour l'isolation des données
  - [ ] Gérer les cas d'erreur et la validation des données
- [ ] Créer l'interface utilisateur d'analyse (AC: 6)
  - [ ] Ajouter le bouton "Analyser" sur la page des dépôts
  - [ ] Implémenter l'affichage en temps réel du progrès
  - [ ] Créer les états de chargement et les indicateurs visuels
  - [ ] Gérer les cas d'erreur avec des messages utilisateur appropriés
- [ ] Optimiser les performances et la gestion des ressources (AC: 4, 7)
  - [ ] Implémenter la pagination pour les gros dépôts
  - [ ] Ajouter des timeouts et des limites de ressources
  - [ ] Créer un système de cache pour éviter les re-analyses
  - [ ] Tester avec des dépôts de différentes tailles

## Dev Notes

### Architecture Technique Pertinente
D'après l'architecture et le PRD, voici les éléments clés pour cette story :

**API GitHub Integration :**
- Utilisation de l'API GitHub Trees pour récupérer l'arborescence complète
- Authentification via les tokens OAuth stockés dans Supabase (de la Story 1.2)
- Gestion des rate limits GitHub (5000 req/h pour utilisateurs authentifiés)
- Support de la récursion pour les dépôts avec sous-modules

**Database Schema (Supabase) :**
```sql
-- Tables à créer selon l'architecture
CREATE TABLE workspaces (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    url TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE knowledge_bases (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    workspace_id UUID REFERENCES workspaces(id) ON DELETE CASCADE,
    structure JSONB,
    created_at TIMESTAMPTZ DEFAULT now()
);
```

**Structure JSON de l'Arborescence :**
Selon l'architecture, la structure doit être optimisée pour la recherche et la navigation :
```typescript
interface FileTreeStructure {
  name: string;
  path: string;
  type: 'file' | 'directory';
  size?: number;
  sha?: string;
  children?: FileTreeStructure[];
  language?: string; // Détecté par extension
}
```

**Performance Requirements (NFR1) :**
- L'analyse doit se terminer en moins de 30 minutes pour 100k lignes de code
- Utilisation de pagination pour les gros dépôts
- Cache des résultats pour éviter les re-analyses
- Timeouts appropriés pour éviter les blocages

**Integration avec Story 1.2 :**
- Réutilisation des tokens GitHub OAuth stockés dans Supabase
- Utilisation des clients Supabase déjà configurés (`lib/supabase/client.ts`, `lib/supabase/server.ts`)
- Extension du middleware d'authentification existant

**Stack Technique à Utiliser :**
- Next.js 15.4.7 API Routes (déjà configuré)
- Supabase Postgres avec RLS (déjà configuré)
- GitHub API REST v4 (intégration existante)
- TypeScript 5.x avec typage strict (déjà configuré)

**Source Tree Structure :**
```
/apps/web/
├── app/api/workspaces/[id]/analyze/route.ts  # Nouvel endpoint d'analyse
├── lib/server/github.ts                      # Utilitaires GitHub server-only
├── lib/database/                             # Helpers base de données
└── app/(pages)/repos/                        # Extension UI existante
```

**Variables d'Environnement (déjà configurées) :**
- `NEXT_PUBLIC_SUPABASE_URL` et `NEXT_PUBLIC_SUPABASE_ANON_KEY` (Supabase)
- `GITHUB_CLIENT_ID` et `GITHUB_CLIENT_SECRET` (GitHub OAuth)

### Testing
**Standards de Test (d'après l'architecture) :**
- **Tests Unitaires :** Jest pour les fonctions d'analyse et parsing
- **Tests d'Intégration :** Jest/React Testing Library pour l'API et l'UI
- **Tests E2E :** Playwright pour le parcours complet d'analyse
- **Tests de Performance :** Validation du respect de la limite de 30 minutes

**Frameworks et Patterns :**
- Jest (Latest) - déjà configuré dans Story 1.1
- React Testing Library - déjà configuré dans Story 1.2
- Playwright (Latest) - déjà configuré dans Story 1.2
- Localisation des tests : colocalisation avec les composants

**Tests Spécifiques à cette Story :**
- Tests unitaires pour le parsing d'arborescence GitHub
- Tests d'intégration pour l'API d'analyse avec mocks GitHub
- Tests de performance avec différentes tailles de dépôts
- Tests E2E du flux complet (sélection dépôt → analyse → résultats)

**Mock Strategy :**
- Mock des réponses GitHub API Trees pour tests reproductibles
- Mock de Supabase pour tests d'intégration isolés
- Test datasets avec différentes structures de dépôts

## Change Log
| Date       | Version | Description              | Auteur |
|------------|---------|--------------------------|--------|
| 12/01/2025 | 1.0     | Création initiale story  | Sarah  |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*This section will be populated by the QA agent after implementation*
